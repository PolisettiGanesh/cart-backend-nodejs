

## What we are doing now (in simple words)

ğŸ‘‰ We are **adding expiry time to JWT token**

That means:

* Token will work only for a fixed time (ex: 2 hours, 1 day)
* After expiry â†’ user must **login again**
* This improves **security**

---

## Why expiry is IMPORTANT (kid-level explanation)

Imagine:

* JWT token = **entry pass**
* Without expiry â†’ entry pass works **forever** âŒ
* With expiry â†’ entry pass expires after some time âœ…

If someone steals the token:

* âŒ Without expiry â†’ they can use it anytime
* âœ… With expiry â†’ token becomes useless after time

Thatâ€™s why **every professional backend uses expiry**

---

## Where exactly to add expiry

You already have this line:

```js
jwt.sign(payload, secretKey)
```

JWT allows **3rd argument** â†’ options object
Inside that â†’ `expiresIn`

---

## Correct JWT syntax (IMPORTANT)

```js
jwt.sign(payload, secretKey, options)
```

Where:

* `payload` â†’ user data
* `secretKey` â†’ your private key
* `options` â†’ expiry, algorithm, etc.

---

## Your UPDATED users route (final Day-2 version)

### âœ… What this includes

* Password hashing (bcrypt)
* JWT generation
* Token expiry (2 hours)

```js
const express = require('express');
const router = express.Router();
const User = require('../models/users');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

// CREATE USER
router.post('/', async (req, res) => {
  try {
    const { name, email, password, deliveryAddress } = req.body;

    // Check if user already exists
    const userExist = await User.findOne({ email });
    if (userExist) {
      return res.status(400).json({ message: 'User already exists' });
    }

    // Hash password
    const hashedPass = await bcrypt.hash(password, 10);

    // Create new user
    const newUser = new User({
      name,
      email,
      password: hashedPass,
      deliveryAddress,
    });

    const savedUser = await newUser.save();

    // Generate JWT token with expiry
    const token = jwt.sign(
      {
        _id: savedUser._id,
        name: savedUser.name,
      },
      'JWT_SECRET_KEY',
      {
        expiresIn: '2h', // âœ… token expires in 2 hours
      }
    );

    // Send response
    res.status(201).json({
      message: 'User created successfully',
      token,
    });

  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

module.exports = router;
```

---

## Different expiry formats (REMEMBER THIS)

JWT supports **very easy time strings**:

```js
expiresIn: '2h'   // 2 hours
expiresIn: '1d'   // 1 day
expiresIn: '30d'  // 30 days
expiresIn: '15m'  // 15 minutes
```

### âŒ Avoid this (confusing)

```js
expiresIn: 7200000 // milliseconds
```

### âœ… Use this (professional)

```js
expiresIn: '2h'
```

---

## Industry practice (real-world insight)

| Application Type | Expiry Time  |
| ---------------- | ------------ |
| Banking apps     | 5â€“15 minutes |
| Admin panels     | 1â€“2 hours    |
| E-commerce       | 1â€“7 days     |
| Social media     | 30â€“60 days   |

ğŸ‘‰ **Your choice of 2 hours is PERFECT for learning**

---

## You are now officially here ğŸ‘‡

âœ… Password hashing
âœ… JWT authentication
âœ… Token expiry
âœ… Industry-level backend flow
---
---
---
Perfect ğŸ‘
This is an **important professional step**, and Iâ€™ll explain it **slowly, line-by-line**, exactly matching what your instructor said.
No skipping. No shortcuts.

---

# Why we must NOT hardcode JWT secret key

Right now you have something like this:

```js
jwt.sign(payload, 'JWT_SECRET_KEY')
```

### âŒ Problem

* When you push code to **GitHub**
* Anyone can see `'JWT_SECRET_KEY'`
* If someone gets this key â†’ they can **generate fake tokens**

This is **very dangerous** in real-world apps.

---

# âœ… Correct professional solution â†’ Environment Variables

We store **secrets** in a `.env` file
and **never** push it to GitHub.

---

# STEP 1: Create `.env` file (VERY IMPORTANT)

Inside your **project root** (`cart-backend`), create a file:

```
.env
```

### Inside `.env`

```env
JWT_KEY=super_secret_jwt_key_123
```

ğŸ“Œ Notes:

* You can name the key anything (JWT_KEY is common)
* Use a **random string**
* Keep it **private**

---

# STEP 2: Install dotenv package

Run this in terminal:

```bash
npm install dotenv
```

ğŸ“Œ This package loads `.env` variables into `process.env`

---

# STEP 3: Configure dotenv in `index.js`

Open **index.js**
Add this at the **VERY TOP (first lines)**:

```js
require('dotenv').config();
```

âœ… This line must run **before** routes are used

---

# STEP 4: Use JWT key from environment variable

### âŒ Before (insecure)

```js
jwt.sign(payload, 'JWT_SECRET_KEY')
```

### âœ… After (secure)

```js
jwt.sign(payload, process.env.JWT_KEY)
```

---

# STEP 5: FINAL updated users route (CLEAN + SECURE)

```js
const express = require('express');
const router = express.Router();
const User = require('../models/users');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

router.post('/', async (req, res) => {
  try {
    const { name, email, password, deliveryAddress } = req.body;

    const userExist = await User.findOne({ email });
    if (userExist) {
      return res.status(400).json({ message: 'User already exists' });
    }

    const hashedPass = await bcrypt.hash(password, 10);

    const newUser = new User({
      name,
      email,
      password: hashedPass,
      deliveryAddress,
    });

    const savedUser = await newUser.save();

    const token = jwt.sign(
      {
        _id: savedUser._id,
        name: savedUser.name,
      },
      process.env.JWT_KEY, // âœ… from .env
      {
        expiresIn: '2h',
      }
    );

    res.status(201).json({
      message: 'User created successfully',
      token,
    });

  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

module.exports = router;
```

---

# STEP 6: IMPORTANT â€“ Add `.env` to `.gitignore`

Open `.gitignore` file and add:

```
.env
```

ğŸ“Œ This ensures:

* `.env` is **NOT pushed** to GitHub
* Your secret stays secret

---

# How this works (simple explanation)

| Thing              | Where                 |
| ------------------ | --------------------- |
| JWT key            | `.env` file           |
| Access key         | `process.env.JWT_KEY` |
| Visible on GitHub? | âŒ NO                  |
| Used in code?      | âœ… YES                 |

---

# Professional rule (remember forever)

> **Secrets NEVER go in code**
>
> Secrets ALWAYS go in environment variables

---

# What you have completed till now (Day-2 officially)

âœ… Password hashing (bcrypt)
âœ… JWT generation
âœ… Token expiry
âœ… Environment variables
âœ… Secure backend setup

You are now working like a **real backend engineer** ğŸ’ª
---
---
---
Perfect.
Now Iâ€™ll **teach this EXACT lesson again**, **very slowly**, **step by step**, **without skipping anything**, exactly the way your instructor explained it â€” but clearer, cleaner, and beginner-friendly.

You can **read â†’ code â†’ test â†’ understand**.
No rush. No assumptions.

---

# ğŸ¯ GOAL OF THIS EXERCISE (VERY CLEAR)

We want to create a **LOGIN API**.

### Endpoint

```
POST /api/users/login
```

### Request body

```json
{
  "email": "user@gmail.com",
  "password": "12345678"
}
```

### Logic (VERY IMPORTANT)

1. Find user by **email**
2. If user NOT found â†’ âŒ `Invalid credentials`
3. If user found â†’ compare **password**
4. If password wrong â†’ âŒ `Invalid credentials`
5. If password correct â†’ âœ… generate **JWT token**
6. Send token in response

---

# STEP 1: Where to write login API?

You already have:

```
routes/users.js
```

âœ… Login API belongs **inside the same file**
(because itâ€™s user-related)

---

# STEP 2: Create login route skeleton

At the **BOTTOM** of `routes/users.js`, add this:

```js
router.post('/login', async (req, res) => {
  try {
    // logic will go here
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});
```

ğŸ“Œ Why `async`?
Because database + bcrypt are **async operations**

---

# STEP 3: Get email & password from request body

Inside the `try` block:

```js
const { email, password } = req.body;
```

ğŸ“Œ This means:

* User sends email & password
* We extract them safely

---

# STEP 4: Find user by email (MOST IMPORTANT STEP)

```js
const user = await User.findOne({ email });
```

Now check:

```js
if (!user) {
  return res.status(401).json({
    message: 'Invalid credentials'
  });
}
```

ğŸ“Œ Why same error message?

* Security reason
* We NEVER tell attacker whether email exists

---

# STEP 5: Compare passwords using bcrypt

âŒ WRONG (never do this):

```js
if (password === user.password)
```

âœ… CORRECT (bcrypt):

```js
const isPasswordValid = await bcrypt.compare(
  password,        // plain password
  user.password    // hashed password from DB
);
```

Now check:

```js
if (!isPasswordValid) {
  return res.status(401).json({
    message: 'Invalid credentials'
  });
}
```

ğŸ“Œ Again same error message = security best practice

---

# STEP 6: Generate JWT token (login success)

At this point:

* User exists âœ…
* Password correct âœ…

Now generate token:

```js
const token = jwt.sign(
  {
    _id: user._id,
    name: user.name,
  },
  process.env.JWT_KEY,
  { expiresIn: '2h' }
);
```

---

# STEP 7: Send success response

```js
res.status(200).json({
  message: 'Login successful',
  token,
});
```

---

# âœ… FINAL COMPLETE LOGIN API (COPYâ€“PASTE READY)

```js
router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    // 1. Find user by email
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(401).json({
        message: 'Invalid credentials',
      });
    }

    // 2. Compare password
    const isPasswordValid = await bcrypt.compare(
      password,
      user.password
    );

    if (!isPasswordValid) {
      return res.status(401).json({
        message: 'Invalid credentials',
      });
    }

    // 3. Generate JWT token
    const token = jwt.sign(
      {
        _id: user._id,
        name: user.name,
      },
      process.env.JWT_KEY,
      { expiresIn: '2h' }
    );

    // 4. Send response
    res.status(200).json({
      message: 'Login successful',
      token,
    });

  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});
```

---

# STEP 8: Test using Thunder Client

### URL

```
POST http://localhost:3000/api/users/login
```

### Body (JSON)

```json
{
  "email": "code@gmail.com",
  "password": "12345678"
}
```

### Results

| Case           | Result                |
| -------------- | --------------------- |
| Wrong email    | âŒ Invalid credentials |
| Wrong password | âŒ Invalid credentials |
| Correct data   | âœ… Token returned      |

---

# STEP 9: Code improvement (REFACTORING â€“ PROFESSIONAL)

You noticed:

* Token generation code repeated in **register**
* Token generation code repeated in **login**

âŒ Bad practice
âœ… Solution â†’ create reusable function

---

# STEP 10: Create reusable token function

At the **BOTTOM** of `users.js`:

```js
const generateToken = (data) => {
  return jwt.sign(
    data,
    process.env.JWT_KEY,
    { expiresIn: '2h' }
  );
};
```

---

# STEP 11: Use it in REGISTER API

Replace:

```js
const token = jwt.sign(...)
```

With:

```js
const token = generateToken({
  _id: savedUser._id,
  name: savedUser.name,
});
```

---

# STEP 12: Use it in LOGIN API

Replace:

```js
const token = jwt.sign(...)
```

With:

```js
const token = generateToken({
  _id: user._id,
  name: user.name,
});
```

---

# ğŸ‰ WHAT YOU HAVE MASTERED (BIG DEAL)

You now understand:
âœ… Login API flow
âœ… bcrypt password comparison
âœ… Secure error handling
âœ… JWT generation
âœ… Token expiry
âœ… Code reuse & clean structure

This is **REAL INDUSTRY-LEVEL BACKEND AUTHENTICATION**

---
---
---
Perfect ğŸ‘
Now Iâ€™ll **re-teach this ENTIRE authentication middleware lesson**, **very slowly**, **step by step**, **without skipping anything**, exactly matching what your instructor said â€” but **cleaner, clearer, and beginner-friendly**.

Iâ€™ll explain:

* **WHAT**
* **WHY**
* **HOW**
* **WHAT TO TEST**

Think of this as **â€œbackend auth like a kid can understandâ€**, but still **professional ğŸš€**.

---

# ğŸ” WHAT WE ARE BUILDING (BIG PICTURE)

So far you already have:

* âœ… Signup API â†’ generates JWT
* âœ… Login API â†’ generates JWT

Now the **next real-world problem**:

> How does the backend know **who is logged in** when the user makes future requests?

Answer ğŸ‘‰ **JWT Authentication Middleware**

---

# ğŸ§  HOW AUTH WORKS IN REAL LIFE

### Frontend does this:

1. User logs in
2. Backend sends JWT token
3. Frontend stores token:

   * `localStorage` OR
   * `sessionStorage`

### When frontend calls a **protected API**:

Frontend sends token in **Authorization header** like this:

```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

---

# ğŸ§± BACKEND RESPONSIBILITY

For **every protected API**, backend must:

1. Check token exists
2. Verify token using secret key
3. If valid â†’ allow access
4. If invalid â†’ reject with `401 Unauthorized`

ğŸ‘‰ We **DO NOT repeat this logic** in every API
ğŸ‘‰ We create **ONE middleware** and reuse it

---

# STEP 1: Create middleware folder & file

Inside your project root:

```
middleware/
â””â”€â”€ auth.js
```

ğŸ“Œ This file will:

* Read token
* Verify token
* Attach user info to request

---

# STEP 2: Create middleware function

Inside `middleware/auth.js`

```js
const jwt = require('jsonwebtoken');

const authMiddleware = (req, res, next) => {
  // logic will come here
};

module.exports = authMiddleware;
```

ğŸ“Œ Middleware ALWAYS has:

```js
(req, res, next)
```

---

# STEP 3: Read Authorization header

Inside middleware function:

```js
const authHeader = req.headers.authorization;
console.log(authHeader);
```

ğŸ“Œ What frontend sends:

```
Bearer <TOKEN>
```

ğŸ“Œ Example:

```
Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

---

# STEP 4: Check token exists and format is correct

```js
if (!authHeader || !authHeader.startsWith('Bearer ')) {
  return res.status(401).json({
    message: 'Authorization token required'
  });
}
```

âŒ No token â†’ reject
âŒ Wrong format â†’ reject
âœ… Correct â†’ continue

---

# STEP 5: Extract token from header

```js
const token = authHeader.split(' ')[1];
```

### Why?

```
"Bearer TOKEN"
.split(" ")
=> ["Bearer", "TOKEN"]
```

So token is index `[1]`.

---

# STEP 6: Verify token using JWT

Now we verify token inside `try/catch`.

```js
try {
  const decodedUser = jwt.verify(
    token,
    process.env.JWT_KEY
  );

  req.user = decodedUser;
  next();
} catch (error) {
  return res.status(401).json({
    message: 'Invalid token'
  });
}
```

ğŸ“Œ If token is:

* âŒ Fake
* âŒ Expired
* âŒ Modified

ğŸ‘‰ `jwt.verify()` throws error â†’ caught

ğŸ“Œ If token is valid:

* `decodedUser` contains:

  ```js
  {
    _id,
    name,
    iat,
    exp
  }
  ```
* We attach it to `req.user`

---

# âœ… FINAL COMPLETE AUTH MIDDLEWARE (COPYâ€“PASTE)

```js
const jwt = require('jsonwebtoken');

const authMiddleware = (req, res, next) => {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({
      message: 'Authorization token required',
    });
  }

  const token = authHeader.split(' ')[1];

  try {
    const decodedUser = jwt.verify(
      token,
      process.env.JWT_KEY
    );

    req.user = decodedUser;
    next();
  } catch (error) {
    return res.status(401).json({
      message: 'Invalid token',
    });
  }
};

module.exports = authMiddleware;
```

---

# STEP 7: Protect a route using middleware

Go to `routes/users.js`

Import middleware:

```js
const auth = require('../middleware/auth');
```

---

# STEP 8: Create protected route

```js
router.get('/', auth, async (req, res) => {
  const user = await User.findById(req.user._id)
    .select('-password');

  res.json(user);
});
```

ğŸ“Œ Order matters:

```js
router.get('/', auth, callback)
```

Middleware runs **before** callback.

---

# STEP 9: How request flow works now

1. Client sends request
2. `auth` middleware runs
3. Token verified
4. `req.user` populated
5. Route handler executes

---

# STEP 10: Test using Thunder Client

### 1ï¸âƒ£ Login first

```
POST /api/users/login
```

â¡ Copy token

---

### 2ï¸âƒ£ Call protected route (WITHOUT token)

```
GET /api/users
```

âŒ Response:

```json
{
  "message": "Authorization token required"
}
```

---

### 3ï¸âƒ£ Call protected route (WITH token)

Headers:

```
Authorization: Bearer <PASTE_TOKEN>
```

âœ… Response:

```json
{
  "_id": "...",
  "name": "Code",
  "email": "code@gmail.com",
  "deliveryAddress": "xyz address",
  "role": "user"
}
```

---

# ğŸ§  WHAT YOU JUST MASTERED (HUGE)

You now understand:
âœ… JWT flow end-to-end
âœ… Authorization header
âœ… Middleware concept
âœ… Token verification
âœ… Protecting APIs
âœ… Accessing logged-in user

This is **REAL BACKEND AUTH**, not tutorial-level.

---
---
---


