Perfect bro üî•
Now I‚Äôll give you **deep, complete, step-by-step Facebook OAuth notes** ‚Äî not surface level ‚Äî real understanding level.

You can directly paste this into:

```
FACEBOOK_OAUTH_NOTES.md
```

---

# üîµ FACEBOOK OAUTH ‚Äì COMPLETE DEEP NOTES

---

# 1Ô∏è‚É£ First Understand: What Is Facebook OAuth?

Facebook OAuth allows users to log in using their Facebook account instead of creating email/password in our system.

Instead of:

```
User ‚Üí Email + Password ‚Üí Our DB
```

It becomes:

```
User ‚Üí Facebook Login ‚Üí Facebook verifies ‚Üí Our backend gets verified identity
```

---

# 2Ô∏è‚É£ What Problem Does OAuth Solve?

Without OAuth:

* We store passwords
* We manage authentication
* We handle security risks

With OAuth:

* Facebook verifies user
* We never see user password
* We only receive verified identity

That‚Äôs why OAuth is secure.

---

# 3Ô∏è‚É£ OAuth Flow (Facebook ‚Äì Authorization Code Flow)

Here is the REAL backend architecture:

```
1) User clicks "Login with Facebook"

2) Browser sends request:
   GET /api/auth/facebook

3) Passport redirects user to Facebook login page

4) User logs into Facebook

5) Facebook generates AUTHORIZATION CODE

6) Facebook redirects user back to:
   /api/auth/facebook/callback?code=XXXXX

7) Passport sends:
   - authorization code
   - client ID
   - client secret
   to Facebook server

8) Facebook verifies everything

9) Facebook returns ACCESS TOKEN

10) Passport fetches user profile

11) Profile attached to req.user

12) Our backend:
    - Find or create user
    - Generate JWT
    - Send response
```

This is the complete cycle.

---

# 4Ô∏è‚É£ Important Concepts

---

## üîê Client ID

Public identifier of your app.

Given by Facebook when you create an app.

Safe to expose.

---

## üîê Client Secret

Private key of your app.

ONLY stored in backend `.env`.

Used when exchanging authorization code for access token.

Never expose to frontend.

---

## üîë Authorization Code

Temporary one-time code generated by Facebook.

Used to exchange for access token.

Expires quickly.

---

## üéü Access Token

Token Facebook gives to backend after verification.

Used to fetch user profile.

---

## üë§ Profile Object

Facebook user data like:

* id
* name
* email
* profile picture

Passport attaches this to:

```
req.user
```

---

# 5Ô∏è‚É£ Step-by-Step Implementation

---

# STEP 1: Install Strategy

```
npm install passport-facebook
```

---

# STEP 2: Create Facebook App

Go to:

```
https://developers.facebook.com
```

### Steps:

1. Create App
2. Choose "Consumer"
3. Add Facebook Login product
4. Add Valid OAuth Redirect URI:

```
http://localhost:3000/api/auth/facebook/callback
```

5. Copy:

   * App ID
   * App Secret

---

# STEP 3: Add to .env

```
FACEBOOK_APP_ID=your_app_id
FACEBOOK_APP_SECRET=your_secret
```

---

# STEP 4: Configure Passport Strategy

üìÅ config/passport.js

```js
const FacebookStrategy = require("passport-facebook").Strategy;

passport.use(
  new FacebookStrategy(
    {
      clientID: process.env.FACEBOOK_APP_ID,
      clientSecret: process.env.FACEBOOK_APP_SECRET,
      callbackURL: "http://localhost:3000/api/auth/facebook/callback",
      profileFields: ["id", "displayName", "emails"],
    },
    async (accessToken, refreshToken, profile, done) => {
      try {
        return done(null, profile);
      } catch (error) {
        return done(error, null);
      }
    }
  )
);
```

---

# Why profileFields is required?

Facebook does NOT send email automatically.

We must explicitly request:

```
profileFields: ["id", "displayName", "emails"]
```

---

# STEP 5: Add Login Route

üìÅ routes/auth.js

```js
router.get(
  "/facebook",
  passport.authenticate("facebook", {
    scope: ["email"],
  })
);
```

What this does:

* Redirects user to Facebook login
* Requests email permission

---

# STEP 6: Add Callback Route

```js
router.get(
  "/facebook/callback",
  passport.authenticate("facebook", { session: false }),
  async (req, res) => {
    try {
      const profile = req.user;

      let user = await User.findOne({
        $or: [
          { facebookId: profile.id },
          { email: profile.emails?.[0]?.value },
        ],
      });

      if (!user) {
        user = new User({
          name: profile.displayName,
          email: profile.emails?.[0]?.value,
          facebookId: profile.id,
        });

        await user.save();
      }

      const token = jwt.sign(
        {
          _id: user._id,
          name: user.name,
        },
        process.env.JWT_KEY,
        { expiresIn: "2h" }
      );

      res.json({
        message: "Facebook login successful",
        user,
        token,
      });

    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  }
);
```

---

# STEP 7: Update User Schema

üìÅ models/users.js

```js
facebookId: {
  type: String,
  unique: true,
  sparse: true,
},
```

Why sparse?

So normal users (email/password) won‚Äôt cause unique error.

---

# 6Ô∏è‚É£ What Happens Internally When User Logs In?

Let‚Äôs go deep.

---

## When user hits:

```
GET /api/auth/facebook
```

Passport builds this URL:

```
https://www.facebook.com/vX.X/dialog/oauth?
client_id=APP_ID
&redirect_uri=CALLBACK_URL
&scope=email
```

Then browser redirects.

---

## After Login

Facebook generates:

```
authorization code
```

And redirects:

```
/api/auth/facebook/callback?code=XXXX
```

---

## Passport Exchanges Code

Passport sends POST request to:

```
https://graph.facebook.com/oauth/access_token
```

With:

* client_id
* client_secret
* redirect_uri
* code

Facebook verifies:

* Is client secret correct?
* Is redirect URI valid?
* Is code valid?

If yes:

Returns:

```
access_token
```

---

## Passport Fetches Profile

Using access token:

```
https://graph.facebook.com/me
```

Gets profile data.

Attaches to:

```
req.user
```

---

## Now Our Backend Logic Runs

* Check DB
* Create or update user
* Generate JWT
* Send response

---

# 7Ô∏è‚É£ Full Architecture Diagram

```
User
 ‚Üì
GET /api/auth/facebook
 ‚Üì
Passport
 ‚Üì
Redirect to Facebook
 ‚Üì
User Login
 ‚Üì
Facebook sends ?code=
 ‚Üì
Backend receives code
 ‚Üì
Passport sends code + secret
 ‚Üì
Facebook returns access_token
 ‚Üì
Passport fetches profile
 ‚Üì
req.user
 ‚Üì
Generate JWT
 ‚Üì
Send response
```

---

# 8Ô∏è‚É£ Why We Still Generate JWT?

Because:

* OAuth verifies identity
* JWT maintains session in our app

Facebook login ‚â† logged into our backend

JWT = our authentication system

---

# 9Ô∏è‚É£ Security Points

* Client secret stays in backend
* Authorization code is temporary
* Access token is used only server-side
* No password stored for Facebook users

---

# üîü Common Errors

| Error                 | Reason                     |
| --------------------- | -------------------------- |
| redirect_uri_mismatch | Wrong callback URL         |
| email not returned    | Missing scope              |
| app not active        | Facebook app not published |
| session error         | Forgot session: false      |

---

# üéØ Final Result

Now your backend supports:

* Email + Password
* Google OAuth
* Facebook OAuth

This is production-level authentication system.

---

If you want next level:

* Account linking (Google + Facebook same email)
* Refresh token system
* Production deployment config
* Role-based auth

Tell me üî•
